// SPDX-License-Identifier: Apache-2.0
// Copyright 2025 ZKPassport
pragma solidity >=0.8.21;

import {DateUtils} from "../src/DateUtils.sol";
import {ZKPassportVerifier, ProofType} from "../src/ZKPassportVerifier.sol";
import {console} from "forge-std/console.sol";

library StringUtils {
  function equals(string memory a, string memory b) internal pure returns (bool) {
    return keccak256(bytes(a)) == keccak256(bytes(b));
  }

  function isEmpty(string memory a) internal pure returns (bool) {
    return bytes(a).length == 0;
  }

  function getWeightedBytes(string memory a) internal pure returns (uint256) {
    uint256 length = bytes(a).length;
    uint256 sum = 0;
    for (uint256 i = length - 1; i > 0; i--) {
      sum += uint256(uint8(bytes(a)[length - 1 - i])) * 2 ** (i * 8);
    }
    return sum;
  }
}

library ArrayUtils {
  function isSortedAscending(string[] memory array) internal pure returns (bool) {
    for (uint256 i = 1; i < array.length; i++) {
      // Ignore empty strings
      if (StringUtils.isEmpty(array[i])) {
        continue;
      }
      if (StringUtils.getWeightedBytes(array[i]) < StringUtils.getWeightedBytes(array[i - 1])) {
        return false;
      }
    }
    return true;
  }
}

contract SampleContract {
  address public admin;
  ZKPassportVerifier public zkPassportVerifier;

  // Unique Identifier => whether it was verified or not
  mapping(bytes32 => bool) public isVerified;
  // Unique Identifier => nationality
  mapping(bytes32 => string) public userNationality;
  // User address => unique identifier
  mapping(address => bytes32) public userUniqueIdentifier;

  constructor() {
    admin = msg.sender;
  }

  modifier onlyAdmin() {
    require(msg.sender == admin, "Only admin can call this function");
    _;
  }

  function setZKPassportVerifier(address _zkPassportVerifier) public onlyAdmin {
    zkPassportVerifier = ZKPassportVerifier(_zkPassportVerifier);
  }

  /**
   * @notice Register a user using a ZKPassport proof
   * @dev No need to understand what the parameters are, the getSolidityVerifierParameters function
   * in the ZKPassport TypeScript's SDK will get them for you so you can pass it to your contract
   */
  function register(
    bytes32 vkeyHash,
    bytes calldata proof,
    bytes32[] calldata publicInputs,
    bytes calldata committedInputs,
    uint256[] calldata committedInputCounts,
    // Disclosed data are formatted differently between
    // passports and ID cards
    // You can ask the user to disclose their document type
    // and the SDK will tell you which one they have
    bool isIDCard
  ) public returns (bytes32) {
    (bool verified, bytes32 uniqueIdentifier) = zkPassportVerifier.verifyProof(
      vkeyHash,
      proof,
      publicInputs,
      committedInputs,
      committedInputCounts,
      // Let's say we want the proof to be valid for a maximum of 2 days
      // i.e. from our perspective, the proof generated by the user expires 2 days after they generate it
      2
    );
    require(verified, "Proof is invalid");
    require(!isVerified[uniqueIdentifier], "User already verified");

    // Get the age condition checked in the proof
    (uint256 currentDate, uint8 minAge, uint8 maxAge) = zkPassportVerifier.getAgeProofInputs(
      committedInputs,
      committedInputCounts
    );
    // Make sure the date used for the proof makes sense
    require(block.timestamp >= currentDate, "Date used in proof is in the future");
    // This is the condition for checking the age is 18 or above
    // Max age is set to 0 and therefore ignored in the proof, so it's equivalent to no upper limit
    // Min age is set to 18, so the user needs to be at least 18 years old
    require(minAge == 18 && maxAge == 0, "User needs to be above 18");

    // Get the disclosed bytes of data from the proof
    (, bytes memory disclosedBytes) = zkPassportVerifier.getDiscloseProofInputs(
      committedInputs,
      committedInputCounts
    );
    // Get the nationality from the disclosed data and ignore the rest
    // Passing the disclosed bytes returned by the previous function
    // this function will format it for you so you can use the data you need
    (, , string memory nationality, , , , , ) = zkPassportVerifier.getDisclosedData(
      disclosedBytes,
      isIDCard
    );

    string[] memory nationalityExclusionList = zkPassportVerifier.getCountryProofInputs(
      committedInputs,
      committedInputCounts,
      ProofType.NATIONALITY_EXCLUSION
    );
    // The exclusion check relies on the country list being sorted in
    // ascending order, if it is not, then the proof has no value
    require(
      ArrayUtils.isSortedAscending(nationalityExclusionList),
      "Nationality exclusion countries must be sorted in ascending order"
    );
    // Let's check the exclusion list checked what we expect
    // Here we expect Spain, Italy and Portugal
    require(
      StringUtils.equals(nationalityExclusionList[0], "ESP") &&
        StringUtils.equals(nationalityExclusionList[1], "ITA") &&
        StringUtils.equals(nationalityExclusionList[2], "PRT"),
      "Not the expected exclusion list"
    );

    // If all good, mark the user as verified
    isVerified[uniqueIdentifier] = true;
    // Store the nationality for later use
    userNationality[uniqueIdentifier] = nationality;
    // Attach the unique identifier to the user address
    // So they don't have to run the check again if they use the same address
    userUniqueIdentifier[msg.sender] = uniqueIdentifier;
    return uniqueIdentifier;
  }

  /**
   * @notice Unregister a user from the contract
   * @dev This function will delete the user's unique identifier and nationality from the contract
   */
  function unregister() public {
    require(userUniqueIdentifier[msg.sender] != bytes32(0), "User is not verified");
    delete isVerified[userUniqueIdentifier[msg.sender]];
    delete userNationality[userUniqueIdentifier[msg.sender]];
    delete userUniqueIdentifier[msg.sender];
  }

  function doStuff() public {
    // Check the user is verified and registered
    require(userUniqueIdentifier[msg.sender] != bytes32(0), "User is not verified");
    // Everything that follows will be conditioned on the sender being registered with a valid proof
    // and meeting all the conditions in the register function
    // Build the rest of your logic here...
  }
}
